<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Snake</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>
  <body>
    <main>
      <script type="text/javascript">
        const IntroScene = {
          key: "IntroScene",
          preload: function () {
            this.load.image("introImage", "images/snake.png");
          },
          create: function () {
            // Add background or other elements for the introduction scene
            // Example: add a background image or text
            const introImage = this.add
              .image(400, 300, "introImage")
              .setScale(0.4)
              .setOrigin(0.5, 0.5); // Center the image

            const title = this.add
              .text(400, 150, "Snake Game", {
                fontSize: "68px",
                fill: "#fff",
              })
              .setOrigin(0.5);

            // Instructions text
            const instructions = this.add
              .text(400, 500, "Press Enter to Start", {
                fontSize: "24px",
                fill: "#fff",
              })
              .setOrigin(0.5);

            // Input event for pressing Enter to start the game
            this.input.keyboard.on(
              "keydown-ENTER",
              function () {
                // Switch to the GameScene when Enter is pressed
                this.scene.start("GameScene");
              },
              this
            );
          },
        };

        const GameScene = {
          key: "GameScene",
          preload: function () {},

          create: function () {
            this.snakeBody = [];
            this.food;
            this.direction = "RIGHT"; // Initial direction
            this.lastMoveTime = 0; // Time of the last move
            this.moveInterval = 200; // Time in ms between moves
            this.gridSize = 25; // Size of each grid cell
            this.lastKeyPressTime = 0; // Time of the last key press
            this.keyPressCooldown = 95; // Time in ms between key presses
            this.isGameOver = false;

            /* DRAW GRID */
            const graphics = this.add.graphics();

            // Set the line style
            graphics.lineStyle(1, 0xffffff, 1);

            // Draw horizontal lines
            for (let y = 0; y < this.game.config.height; y += this.gridSize) {
              graphics.moveTo(0, y);
              graphics.lineTo(this.game.config.width, y);
            }

            // Draw vertical lines
            for (let x = 0; x < this.game.config.width; x += this.gridSize) {
              graphics.moveTo(x, 0);
              graphics.lineTo(x, this.game.config.height);
            }

            // Stroke the lines to make them visible
            graphics.strokePath();

            this.gameOverText = this.add
              .text(400, 230, "Game Over!", {
                fontSize: "68px",
                fill: "#fff",
                align: "center",
              })
              .setOrigin(0.5, 0.5)
              .setVisible(false); // Initially invisible

            // Press Enter to Restart Text
            this.restartText = this.add
              .text(400, 340, "Press Enter to Restart", {
                fontSize: "24px",
                fill: "#fff",
              })
              .setOrigin(0.5, 0.5)
              .setVisible(false); // Initially invisible

            createSnake.call(this);

            // Handle input
            this.input.keyboard.on("keydown", (event) => {
              const currentTime = this.time.now;

              // Check if enough time has passed since the last key press
              if (
                currentTime - this.lastKeyPressTime >=
                this.keyPressCooldown
              ) {
                if (event.key === "ArrowUp" && this.direction !== "DOWN") {
                  this.direction = "UP";
                } else if (
                  event.key === "ArrowDown" &&
                  this.direction !== "UP"
                ) {
                  this.direction = "DOWN";
                } else if (
                  event.key === "ArrowLeft" &&
                  this.direction !== "RIGHT"
                ) {
                  this.direction = "LEFT";
                } else if (
                  event.key === "ArrowRight" &&
                  this.direction !== "LEFT"
                ) {
                  this.direction = "RIGHT";
                }

                // Update the last key press time
                this.lastKeyPressTime = currentTime;
              }
            });
          },

          update: function (time) {
            if (this.isGameOver) {
              this.gameOverText.setVisible(true);
              this.restartText.setVisible(true);

              if (
                this.input.keyboard.checkDown(
                  this.input.keyboard.addKey(
                    Phaser.Input.Keyboard.KeyCodes.ENTER
                  ),
                  500
                )
              ) {
                this.scene.restart(); // Restart the game when Enter is pressed
              }
              return;
            }

            if (time - this.lastMoveTime >= this.moveInterval) {
              const ateFood =
                this.snakeBody[0].x === this.food.x &&
                this.snakeBody[0].y === this.food.y;
              moveSnake.call(this, {
                snakeBody: this.snakeBody,
                gridSize: this.gridSize,
                ateFood,
                food: this.food,
              });
              this.lastMoveTime = time;
            }
          },
        };

        const config = {
          type: Phaser.AUTO,
          width: 800,
          height: 600,
          backgroundColor: "#a0d9b0",
          scene: [IntroScene, GameScene],
        };

        const game = new Phaser.Game(config);

        function createSnake() {
          // Get grid column and row numbers
          const gridColumns = Math.floor(
            this.game.config.width / this.gridSize
          );
          const gridRows = Math.floor(this.game.config.height / this.gridSize);

          // Generate random column and row
          let column = Phaser.Math.Between(5, gridColumns - 5);
          let row = Phaser.Math.Between(5, gridRows - 5);

          // Create snake head
          const head = createPart.call(this, {
            column,
            row,
            gridSize: this.gridSize,
          });
          this.snakeBody.push(head);

          // Create snake body
          row--;
          const part1 = createPart.call(this, {
            column,
            row,
            gridSize: this.gridSize,
          });
          this.snakeBody.push(part1);
          row--;
          const part2 = createPart.call(this, {
            column,
            row,
            gridSize: this.gridSize,
          });
          this.snakeBody.push(part2);

          // Add snake to grid
          for (const part of this.snakeBody) {
            this.add.existing(part);
          }

          createFood.call(this, this.snakeBody);
        }

        function createPart({ column, row, gridSize }) {
          const xPosition = column * gridSize + gridSize / 2;
          const yPosition = row * gridSize + gridSize / 2;
          const part = new Phaser.GameObjects.Rectangle(
            this,
            xPosition,
            yPosition,
            gridSize,
            gridSize,
            0xfcba03
          );
          part.setStrokeStyle(1, 0xffffff);
          return part;
        }

        function moveSnake({ snakeBody, gridSize, ateFood, food }) {
          if (ateFood) {
            const lastPart = snakeBody[snakeBody.length - 1];
            let newX = lastPart.x;
            let newY = lastPart.y;

            if (this.direction === "UP") {
              newY += gridSize;
            } else if (this.direction === "DOWN") {
              newY -= gridSize;
            } else if (this.direction === "LEFT") {
              newX += gridSize;
            } else if (this.direction === "RIGHT") {
              newX -= gridSize;
            }

            const newPart = new Phaser.GameObjects.Rectangle(
              this,
              newX,
              newY,
              gridSize,
              gridSize,
              0xfcba03
            );
            newPart.setStrokeStyle(1, 0xffffff);
            snakeBody.push(newPart);
            this.add.existing(newPart);

            repositionFood.call(this, { snakeBody, food });
          }

          for (let i = snakeBody.length - 1; i > 0; i--) {
            snakeBody[i].x = snakeBody[i - 1].x;
            snakeBody[i].y = snakeBody[i - 1].y;
          }

          const head = snakeBody[0];
          if (this.direction === "UP") {
            head.y -= gridSize;
          } else if (this.direction === "DOWN") {
            head.y += gridSize;
          } else if (this.direction === "LEFT") {
            head.x -= gridSize;
          } else if (this.direction === "RIGHT") {
            head.x += gridSize;
          }

          // Check for collision with walls
          if (
            head.x < 0 ||
            head.x >= this.game.config.width ||
            head.y < 0 ||
            head.y >= this.game.config.height
          ) {
            this.isGameOver = true;
            console.log("Game Over! The snake hit the wall.");
          }

          // Check for collision with itself
          for (let i = 1; i < snakeBody.length; i++) {
            if (head.x === snakeBody[i].x && head.y === snakeBody[i].y) {
              this.isGameOver = true;
              console.log("Game Over! The snake collided with itself.");
              break;
            }
          }
        }

        function createFood(snakeBody) {
          const gridColumns = Math.floor(
            this.game.config.width / this.gridSize
          );
          const gridRows = Math.floor(this.game.config.height / this.gridSize);

          let foodColumn;
          let foodRow;
          let foodPositionIsValid = false;

          // Keep generating food until it's in a valid position
          while (!foodPositionIsValid) {
            foodColumn = Phaser.Math.Between(0, gridColumns - 1);
            foodRow = Phaser.Math.Between(0, gridRows - 1);

            // Check if the food position is not inside the snake's body
            const foodPosition = { column: foodColumn, row: foodRow };
            foodPositionIsValid = !isSnakeAtPosition({
              snakeBody,
              position: foodPosition,
              gridSize: this.gridSize,
            });
          }

          // Create the food
          const xPosition = foodColumn * this.gridSize + this.gridSize / 2;
          const yPosition = foodRow * this.gridSize + this.gridSize / 2;
          const food = new Phaser.GameObjects.Rectangle(
            this,
            xPosition,
            yPosition,
            this.gridSize,
            this.gridSize,
            0xf78383
          );
          food.setStrokeStyle(1, 0xffffff);
          this.food = food;
          this.add.existing(food);
        }

        function repositionFood({ snakeBody, food }) {
          const gridColumns = Math.floor(
            this.game.config.width / this.gridSize
          );
          const gridRows = Math.floor(this.game.config.height / this.gridSize);

          let foodColumn;
          let foodRow;
          let foodPositionIsValid = false;

          // Keep generating food until it's in a valid position
          while (!foodPositionIsValid) {
            foodColumn = Phaser.Math.Between(0, gridColumns - 1);
            foodRow = Phaser.Math.Between(0, gridRows - 1);

            // Check if the food position is not inside the snake's body
            const foodPosition = { column: foodColumn, row: foodRow };
            foodPositionIsValid = !isSnakeAtPosition({
              snakeBody,
              position: foodPosition,
              gridSize: this.gridSize,
            });
          }

          // Set the food position
          const xPosition = foodColumn * this.gridSize + this.gridSize / 2;
          const yPosition = foodRow * this.gridSize + this.gridSize / 2;
          food.x = xPosition;
          food.y = yPosition;
        }

        function isSnakeAtPosition({ snakeBody, position, gridSize }) {
          // Check if the snake's body contains the given position
          for (const part of snakeBody) {
            if (
              part.x === position.column * gridSize + gridSize / 2 &&
              part.y === position.row * gridSize + gridSize / 2
            ) {
              return true;
            }
          }
          return false;
        }
      </script>
    </main>
  </body>
</html>
